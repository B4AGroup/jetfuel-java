package com.eixox.database;

import java.lang.reflect.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import com.eixox.data.Aggregate;
import com.eixox.data.AggregateFilter;
import com.eixox.data.AggregateFilterExpression;
import com.eixox.data.AggregateFilterNode;
import com.eixox.data.AggregateFilterTerm;
import com.eixox.data.Filter;
import com.eixox.data.FilterComparison;
import com.eixox.data.FilterExpression;
import com.eixox.data.FilterNode;
import com.eixox.data.FilterTerm;
import com.eixox.data.SelectAggregate;
import com.eixox.data.SortDirection;
import com.eixox.data.SortExpression;
import com.eixox.data.SortNode;

public class DatabaseCommand {

	public final StringBuilder text = new StringBuilder();
	public final ArrayList<Object> params = new ArrayList<Object>();
	public final Database database;

	public DatabaseCommand(Database database) {
		this.database = database;
	}

	public final DatabaseCommand appendSql(String value) {
		this.text.append(value);
		return this;
	}

	public final PreparedStatement prepareStatement(Connection conn, int autoGeneratedKeys) throws SQLException {
		int pCount = params.size();
		PreparedStatement stmt = conn.prepareStatement(this.text.toString(), autoGeneratedKeys);
		for (int i = 0; i < pCount; i++)
			stmt.setObject(i + 1, params.get(i));
		return stmt;
	}

	public final boolean execute() throws SQLException {
		Connection conn = this.database.createConnection();
		try {
			return execute(conn);
		} finally {
			conn.close();
		}
	}

	public final boolean execute(Connection conn) throws SQLException {
		PreparedStatement ps = prepareStatement(conn, Statement.NO_GENERATED_KEYS);
		try {
			return ps.execute();
		} finally {
			ps.close();
		}
	}

	public final int executeUpsert() throws SQLException {
		Connection conn = this.database.createConnection();
		try {
			return executeUpsert(conn);
		} finally {
			conn.close();
		}
	}

	public final int executeUpsert(Connection conn) throws SQLException {
		PreparedStatement ps = prepareStatement(conn, Statement.NO_GENERATED_KEYS);
		try {
			return ps.executeUpdate();
		} finally {
			ps.close();
		}
	}

	public final Object executeScalar() throws SQLException {
		Connection conn = this.database.createConnection();
		try {
			return executeScalar(conn);
		} finally {
			conn.close();
		}
	}

	public final Object executeScalar(Connection conn) throws SQLException {
		PreparedStatement ps = prepareStatement(conn, Statement.NO_GENERATED_KEYS);
		ResultSet rs = ps.executeQuery();
		try {
			return rs.next() ? rs.getObject(1) : null;
		} finally {
			rs.close();
			ps.close();
		}
	}

	public final <T> T executeQuery(Connection conn, DatabaseCommandProcessor<T> processor) throws SQLException {
		PreparedStatement ps = prepareStatement(conn, Statement.NO_GENERATED_KEYS);
		ResultSet rs = ps.executeQuery();
		try {
			return processor.process(rs);
		} finally {
			rs.close();
			ps.close();
		}

	}

	public final <T> T executeQuery(DatabaseCommandProcessor<T> processor) throws SQLException {
		Connection conn = this.database.createConnection();
		try {
			return executeQuery(conn, processor);
		} finally {
			conn.close();
		}
	}

	public final <T> T executeInsert(Connection conn, DatabaseCommandProcessor<T> processor) throws SQLException {
		PreparedStatement ps = prepareStatement(conn, Statement.RETURN_GENERATED_KEYS);
		ps.executeUpdate();
		ResultSet rs = ps.getGeneratedKeys();
		try {
			return processor.process(rs);
		} finally {
			rs.close();
			ps.close();
		}
	}

	public final DatabaseCommand appendName(String name) {
		this.text.append(database.getNamePrefix());
		this.text.append(name);
		this.text.append(database.getNameSuffix());
		return this;
	}

	public final DatabaseCommand appendName(String... names) {
		appendName(names[0]);
		for (int i = 1; i < names.length; i++) {
			this.text.append(", ");
			appendName(names[i]);
		}
		return this;
	}

	public final DatabaseCommand appendNames(List<String> names) {
		if (names != null && names.size() > 0) {
			appendName(names.get(0));
			for (int i = 1; i < names.size(); i++) {
				this.text.append(", ");
				appendName(names.get(i));
			}
		}
		return this;
	}

	public final DatabaseCommand appendNames(List<String> names, List<SelectAggregate> aggregates) {
		if (names != null && names.size() > 0) {
			appendName(names.get(0));
			for (int i = 1; i < names.size(); i++) {
				this.text.append(", ");
				appendName(names.get(i));
			}
		}
		if (aggregates != null && aggregates.size() > 0) {
			if (names != null && names.size() > 0)
				this.text.append(", ");

			SelectAggregate aggregate = aggregates.get(0);
			this.text.append(aggregate.aggregate.toString());
			this.text.append("(");
			appendName(aggregate.name);
			this.text.append(") as ");
			appendName(aggregate.alias == null || aggregate.alias.isEmpty() ? aggregate.name : aggregate.alias);

			for (int i = 1; i < aggregates.size(); i++) {
				aggregate = aggregates.get(i);
				this.text.append(", ");
				this.text.append(aggregate.aggregate.toString());
				this.text.append("(");
				appendName(aggregate.name);
				this.text.append(") as ");
				appendName(aggregate.alias == null || aggregate.alias.isEmpty() ? aggregate.name : aggregate.alias);
			}
		}
		return this;
	}

	public final DatabaseCommand appendWhere(FilterExpression where) {
		if (where != null && where.first != null) {
			this.text.append(" WHERE ");
			appendFilter(where.first);
		}
		return this;
	}

	public final DatabaseCommand appendHaving(AggregateFilterExpression having) {
		if (having != null && having.first != null) {
			this.text.append(" HAVING ");
			appendAggregateFilter(having);
		}
		return this;
	}

	public final DatabaseCommand appendGroupBy(List<String> cols) {
		if (cols != null && cols.size() > 0) {
			this.text.append(" GROUP BY ");
			appendNames(cols);
		}
		return this;
	}

	public final DatabaseCommand appendOrderBy(SortExpression sort) {
		if (sort != null && sort.first != null) {
			this.text.append(" ORDER BY ");

			SortNode node = sort.first;
			if (node.aggregate != Aggregate.NONE) {
				this.text.append(node.aggregate.toString());
				this.text.append("(");
				appendName(node.name);
				this.text.append(")");
			} else {
				appendName(node.name);
			}
			if (node.direction == SortDirection.DESC)
				this.text.append(" DESC");

			for (node = node.next; node != null; node = node.next) {
				this.text.append(", ");
				if (node.aggregate != Aggregate.NONE) {
					this.text.append(node.aggregate.toString());
					this.text.append("(");
					appendName(node.name);
					this.text.append(")");
				} else {
					appendName(node.name);
				}
				if (node.direction == SortDirection.DESC)
					this.text.append(" DESC");
			}
		}
		return this;
	}

	public final DatabaseCommand appendFilter(Filter filter) {
		switch (filter.getFilterType()) {
		case EXPRESSION:
			FilterExpression expression = (FilterExpression) filter;
			this.text.append("(");
			appendFilter(expression.first);
			this.text.append(")");
			return this;
		case NODE:
			FilterNode node = (FilterNode) filter;
			appendFilter(node.filter);
			if (node.next != null) {
				switch (node.operation) {
				case AND:
					this.text.append(" AND ");
					appendFilter(node.next);
					break;
				case OR:
					this.text.append(" OR ");
					appendFilter(node.next);
					break;
				default:
					throw new RuntimeException("Unknwon filter operation " + node.operation);
				}
			}
			return this;
		case TERM:
			FilterTerm term = (FilterTerm) filter;
			appendName(term.name);
			appendComparison(term.comparison, term.value);
			return this;
		default:
			throw new RuntimeException("Unknown filter type " + filter.getFilterType());

		}

	}

	public final DatabaseCommand appendAggregateFilter(AggregateFilter filter) {
		switch (filter.getFilterType()) {
		case EXPRESSION:
			AggregateFilterExpression expression = (AggregateFilterExpression) filter;
			this.text.append("(");
			appendFilter(expression.first);
			this.text.append(")");
			return this;
		case NODE:
			AggregateFilterNode node = (AggregateFilterNode) filter;
			appendFilter(node.filter);
			if (node.next != null) {
				switch (node.operation) {
				case AND:
					this.text.append(" AND ");
					break;
				case OR:
					this.text.append(" OR ");
					break;
				default:
					throw new RuntimeException("Unknwon filter operation " + node.operation);
				}
			}
			return this;
		case TERM:
			AggregateFilterTerm term = (AggregateFilterTerm) filter;
			this.text.append(term.aggregate.toString());
			this.text.append("(");
			appendName(term.name);
			this.text.append(")");
			appendComparison(term.comparison, term.value);
			return this;
		default:
			throw new RuntimeException("Unknown filter type " + filter.getFilterType());

		}

	}

	public final DatabaseCommand appendComparison(FilterComparison comparison, Object value) {
		switch (comparison) {
		case EQUAL_TO:
			if (value == null)
				this.text.append(" IS NULL");
			else {
				this.text.append(" = ?");
				this.params.add(value);
			}
			return this;
		case GREATER_OR_EQUAL:
			this.text.append(" >= ?");
			this.params.add(value);
			return this;
		case GREATER_THAN:
			this.text.append(" > ?");
			this.params.add(value);
			return this;
		case LIKE:
			this.text.append(" LIKE ?");
			this.params.add(value);
			return this;
		case LOWER_OR_EQUAL:
			this.text.append(" <= ?");
			this.params.add(value);
			return this;
		case LOWER_THAN:
			this.text.append(
					" < ?");
			this.params.add(value);
			return this;
		case NOT_EQUAL_TO:
			if (value == null)
				this.text.append(" IS NOT NULL");
			else {
				this.text.append(" != ?");
				this.params.add(value);
			}
			return this;
		case IN:
			this.text.append(" IN (");
			appendValueCollection(value);
			this.text.append(")");
			return this;
		case NOT_IN:
			this.text.append(" NOT IN (");
			appendValueCollection(value);
			this.text.append(")");
			return this;
		case NOT_LIKE:
			this.text.append(" LIKE ?");
			this.params.add(value);
			return this;
		default:
			throw new RuntimeException("Unknown filter comparison " + comparison);
		}

	}

	private void appendValueCollection(Object value) {
		if (value != null) {
			if (value.getClass().isArray()) {
				int s = Array.getLength(value);
				if (s > 0) {
					Object item = Array.get(value, 0);
					this.text.append('?');
					this.params.add(item);
					for (int i = 1; i < s; i++) {
						item = Array.get(value, i);
						this.text.append(", ?");
						this.params.add(item);
					}
				}
			} else if (List.class.isAssignableFrom(value.getClass())) {
				List<?> list = (List<?>) value;
				int s = list.size();
				if (s > 0) {
					Object item = list.get(0);
					this.text.append('?');
					this.params.add(item);
					for (int i = 1; i < s; i++) {
						item = list.get(i);
						this.text.append(", ?");
						this.params.add(item);
					}
				}
			} else if (Iterable.class.isAssignableFrom(value.getClass())) {
				boolean prependComma = false;
				for (Object item : ((Iterable<?>) value)) {
					if (prependComma)
						this.text.append(", ");
					else
						prependComma = true;

					this.text.append('?');
					this.params.add(item);
				}
			} else {
				this.text.append('?');
				this.params.add(value);
			}
		}
	}

	public final DatabaseCommand appendTop(int count) {
		if (count > 0 &&
				this.database.supportsTOP()) {
			this.text.append(" TOP (");
			this.text.append(count);
			this.text.append(") ");
		}
		return this;
	}

	public final DatabaseCommand appendOffset(int offset) {
		if (offset > 0 &&
				this.database.supportsOFFSET()) {
			this.text.append(" OFFSET ");
			this.text.append(offset);
			this.text.append(' ');
		}
		return this;
	}

	public final DatabaseCommand appendLimit(int pageSize) {
		if (pageSize > 0
				&& this.database.supportsOFFSET()) {
			this.text.append(" LIMIT ");
			this.text.append(pageSize);
			this.text.append(' ');
		}
		return this;
	}

	/*
	 * 
	 * public final DatabaseCommand appendNames(Iterable<String> names) {
	 * boolean prependComma = false; for (String s : names) { if (prependComma)
	 * this.text.append(", "); else prependComma = true;
	 * 
	 * appendName(s); } return this; }
	 * 
	 * public final <T> DatabaseCommand
	 * appendMembers(List<EntityAspectMember<T>> members) { int s =
	 * members.size(); EntityAspectMember<T> member = members.get(0);
	 * appendAggregate(member.aggregate, member.columName, member.getAlias());
	 * for (int i = 1; i < s; i++) { member = members.get(i); text.append(", ");
	 * appendAggregate(member.aggregate, member.columName, member.getAlias()); }
	 * return this; }
	 * 
	 * public final DatabaseCommand appendAggregate(Aggregate aggregate, String
	 * column, String alias) { if (aggregate == Aggregate.NONE) { if (alias ==
	 * null || alias.isEmpty() || alias.equals(column)) { appendName(column); }
	 * else { appendName(column); this.text.append(" as "); appendName(alias); }
	 * } else { this.text.append(aggregate.toString()); this.text.append('(');
	 * appendName(column); this.text.append(") as "); appendName(alias); }
	 * return this; }
	 * 
	 * public final DatabaseCommand appendParameter(Object value) {
	 * this.text.append('?'); this.params.add(value); return this; }
	 * 
	 * public final DatabaseCommand appendParameters(Object... values) {
	 * this.text.append('?'); this.params.add(values[0]); for (int i = 1; i <
	 * values.length; i++) { this.text.append(", ?");
	 * this.params.add(values[i]); } return this; }
	 * 
	 * public final DatabaseCommand appendParameters(Iterable<Object> values) {
	 * boolean prependComma = false; for (Object o : values) { if (prependComma)
	 * this.text.append(", "); else prependComma = true;
	 * 
	 * this.text.append('?'); this.params.add(o); } return this; }
	 * 
	 * public final DatabaseCommand appendIterableParameter(Iterable<?>
	 * iterable) { boolean prependComma = false; for (Object o : iterable) { if
	 * (prependComma) this.text.append(","); else prependComma = true;
	 * 
	 * this.text.append("?"); this.params.add(o); } return this; }
	 * 
	 * public final DatabaseCommand appendFilter(Filter filter) { switch
	 * (filter.getFilterType()) { case EXPRESSION: FilterExpression expression =
	 * (FilterExpression) filter; if (expression != null &&
	 * !expression.isEmpty()) { text.append("(");
	 * appendFilter(expression.first); text.append(")"); } return this; case
	 * NODE: FilterNode node = (FilterNode) filter; appendFilter(node.filter);
	 * if (node.next != null) switch (node.operation) { case AND: text.append(
	 * " AND "); appendFilter(node.next); break; case OR: text.append(" OR ");
	 * appendFilter(node.next); break; default: throw new RuntimeException(
	 * "Unknown filter operation " + node.operation); } return this; case TERM:
	 * FilterTerm term = (FilterTerm) filter; appendName(term.name); return
	 * appendFilter(term.comparison, term.value); default: throw new
	 * RuntimeException("Unknwon filter type " + filter.getFilterType());
	 * 
	 * } }
	 * 
	 * 
	 * 
	 * public final <T> DatabaseCommand appendFilter(EntityFilter<T> filter) {
	 * switch (filter.getFilterType()) { case EXPRESSION: this.text.append("(");
	 * this.appendFilter(((EntityFilterExpression<T>) filter).first);
	 * this.text.append(")"); return this; case NODE: final EntityFilterNode<T>
	 * node = (EntityFilterNode<T>) filter; this.appendFilter(node.filter); if
	 * (node.next != null) { switch (node.operation) { case AND:
	 * this.text.append(" AND "); break; case OR: this.text.append(" OR ");
	 * break; default: throw new RuntimeException("Unknwon filter operation: " +
	 * node.operation); } this.appendFilter(node.next); } return this; case
	 * TERM: EntityFilterTerm<T> term = (EntityFilterTerm<T>) filter;
	 * appendAggregate(term.member.aggregate, term.member.columName,
	 * term.member.getAlias()); return appendFilter(term.comparison,
	 * term.value);
	 * 
	 * default: throw new RuntimeException("Unknown filter type: " +
	 * filter.getFilterType()); }
	 * 
	 * }
	 * 
	 * public final DatabaseCommand appendWhere(FilterExpression exp) { if
	 * (!exp.isEmpty()) { this.text.append(" WHERE "); appendFilter(exp.first);
	 * } return this; }
	 * 
	 * public final <T> DatabaseCommand appendWhere(EntityFilterExpression<T>
	 * where) { if (where != null) { this.text.append(" WHERE ");
	 * appendFilter(where); } return this; }
	 * 
	 * public final <T> DatabaseCommand appendOrderBy(EntitySortExpression<T>
	 * orderBy) { if (orderBy != null) { this.text.append(" ORDER BY ");
	 * appendSortExpression(orderBy); } return this; }
	 * 
	 * public final <T> DatabaseCommand appendGroupBy(EntityAspect<T> aspect) {
	 * if (aspect.hasAggregates) { this.text.append(" GROUP BY "); boolean
	 * prependComma = false; for (EntityAspectMember<T> member : aspect) { if
	 * (member.aggregate == Aggregate.NONE) { if (prependComma)
	 * this.text.append(", "); else prependComma = true;
	 * appendName(member.columName); } }
	 * 
	 * } return this; }
	 * 
	 * private final <T> void appendSortNode(EntitySortNode<T> node) { switch
	 * (node.member.aggregate) { case NONE:
	 * this.appendName(node.member.columName); break; default:
	 * this.text.append(node.member.aggregate.toString());
	 * this.text.append("("); appendName(node.member.columName);
	 * this.text.append(")"); } if (node.direction == SortDirection.DESC)
	 * this.text.append(" DESC"); }
	 * 
	 * public final <T> DatabaseCommand
	 * appendSortExpression(EntitySortExpression<T> exp) { EntitySortNode<T>
	 * node = exp.first; appendSortNode(node); for (node = node.next; node !=
	 * null; node = node.next) { this.text.append(", "); appendSortNode(node); }
	 * return this; }
	 * 
	 * 
	 * 
	 * 
	 */
}
